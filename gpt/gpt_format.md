GPT分区数据格式分析
========================================

背景与前言
----------------------------------------

随着技术的不断提高，电子产品的集成度变得越来越高，硬盘是这几年中的一个突出产品，
近年来，硬盘容量不断提升，从500G到1TB，目前已经能以很便宜的价格买到3TB的硬盘。
分区就是把一块大的物理硬盘分成一个一个的逻辑盘，这样便于文档归类，减少坏道损失。
传统的分区格式我们称其为MBR分区，传统的MBR分区格式有一个2TB的限制：当个分区大小不能超过2TB。
以前在企业和服务器领域，一个分区达到2T的情况很正常，所以GPT分区其实很早就已经出现了，只是个人用户用不到而已。
现在，很多人自己就能话很少的钱达到组建几TB的磁盘阵列，所以现在个人用户的操作系统也开始使用GPT分区了。
网络上介绍MBR分区的文章很多，本文不做赘述。但对于GPT分区，至少我前段时间查资料发现深入讲解的文章还不算多。
本文就GPT分区格式进行简单的讲解。

术语及缩写
----------------------------------------

* GPT - GUID Partition Table

* MBR - Master Boot Record

* LBA - Logic Block Address

GPT分区数据格式
----------------------------------------

### LBA0

LBA0就是存储设备的第0个逻辑存储块。

**逻辑存储块**: 是与物理存储块进行区分的，因为目前的工艺水平导致不论NAND还是机械硬盘都存在
坏块的情况，在使用存储设备时，遇到损坏的存储块就会被驱动程序或固件自动跳过，因此坏块对于
驱动程序以上的应用程序来说是透明的，他们感受不到坏块，也不关注坏块，他们对存储设备的存储块
进行的编号称为逻辑块地址（也可以叫：逻辑块编号）。

GPT分区为了兼容传统的MBR分区，其第一个逻辑块数据格式与MBR分区一致，即：第一个逻辑块就是MBR
（主引导记录）。但为了与传统的MBR分区进行区分，GPT分区的分区类型为EE，在传统的MBR中，EE类型
的分区表示保护类型，GPT以此来防止其数据被无意间篡改。
GPT分区的数据格式如下图所示：

https://github.com/leeminghao/doc-linux/blob/master/misc/gpt/gpt.jpeg

在GPT分区中，每一个数据读写单元成为LBA（逻辑块地址）,一个"逻辑块"相当于传统MBR分区中的一个“扇区”，
之所以会有区别，是因为GPT除了要支持传统硬盘，还需要支持以NAND FLASH为材料的SSD硬盘，这些硬盘的
一个读写单元是2KB或4KB，所以GPT分区中干脆用LBA来表示一个基础读写块，当GPT分区用在传统硬盘上时，
通常，LBA就等于扇区号，有些物理硬盘支持2KB对齐，此时LBA所表示的一个逻辑块就是2KB的空间。
为了方便，我们后面仍然将逻辑块称为块。

一般情况下，gpt中各个块的信息如下所示:

* 第0块：和传统MBR分区一样，仍然为主引导记录.
* 第1块：我们称之为"主分区头".
* 第2~33块：共计32个扇区，我们称之为"主分区节点".
* 最后一个块（-1块）: 我们称之为"备份分区头"，它就是"主分区头"的一个Copy.
* 从-2~-33块：共计32个扇区，我们称之为"备份分区节点"，它就是"主分区节点"的一个Copy.
* 第34~-34块：正常的GPT分区内容，文件系统（如：FAT，NTFS，EXT等）就是构建在这里面.

下面我们以

https://github.com/leeminghao/doc-linux/blob/master/misc/gpt/gpt_both0.bin

这个gpt文件为例，来描述下GPT中各个块的信息, 使用hexdump将gpt_both0.bin转换为可读文件:

```
$ hexdump -Cv gpt_both0.bin > gpt_both0.txt
```

https://github.com/leeminghao/doc-linux/blob/master/misc/gpt/gpt_both0.txt

在这里我们定义的块大小如下所示:

```
#define BLOCK_SIZE                0x200 // 512 字节
```

从如下gpt_both0.txt文件中可以看出来： 只定义了一个主分区，且其类型为0xee

```
000001c0  01 00 ee ff ff ff 01 00  00 00 ff ff ff ff 00 00  |................|
000001d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000001e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|
```

bootloader(或BIOS)根据这个ee就能知道这是一个GPT分区表。

### LBA1

GPT分区的LBA1中存放的内容我们称为“主分区头（Primary GPT Header）”，主分区头的数据格式如下：

```
字节偏移    长度     内容

0           8字节    签名（"EFI PART", 45 46 49 20 50 41 52 54）

8           4字节    修订版本号（在1.0版中，值是 00 00 01 00）

12          4字节    分区头的大小（单位是字节，通常是92字节，即 5C 00 00 00）

16          4字节    分区头（第0－91字节）的CRC32校验，计算前需先将此内容写0

20          4字节    保留，必须是 0

24          8字节    当前LBA（这个分区表头的位置）

32          8字节    备份LBA（另一个分区表头的位置）

40          8字节    第一个可用于分区的LBA（主分区表的最后一个LBA + 1）

48          8字节    最后一个可用于分区的LBA（备份分区表的第一个LBA − 1）

56          16字节   硬盘GUID（在类UNIX系统中也叫UUID）

72          8字节    分区表项的起始LBA（在主分区表中是2）

80          4字节    分区表项的数量

84          4字节    一个分区表项的大小（通常是128）

88          4字节    CRC32 of partition array

92           *       保留，剩余的字节必须是0（对于512B/LBA的硬盘就是420个字节）
```

在gpt_both0.txt中如下所示:

```
00000200  45 46 49 20 50 41 52 54  00 00 01 00 5c 00 00 00  |EFI PART....\...|
00000210  7f 5b c4 61 00 00 00 00  01 00 00 00 00 00 00 00  |.[.a............|
00000220  00 00 00 00 00 00 00 00  22 00 00 00 00 00 00 00  |........".......|
00000230  00 00 00 00 00 00 00 00  32 1b 10 98 e2 bb f2 4b  |........2......K|
00000240  a0 6e 2b b3 3d 00 0c 20  02 00 00 00 00 00 00 00  |.n+.=.. ........|
00000250  1c 00 00 00 80 00 00 00  91 c4 a4 65 00 00 00 00  |...........e....|
00000260  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000270  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000280  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000290  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000002a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000002b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000002c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000002d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000002e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000002f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000300  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000310  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000320  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000330  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000340  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000350  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000360  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000370  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000380  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000390  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000003a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000003b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000003c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000003d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000003e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000003f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
"
```

### LBA2~LBA33

LBA2到LBA33，一共32个逻辑块，是用于存储分区表项的，每一个分区表项就描述了一个分区，
分区表项的数据格式如下：

起始字节    长度        内容

0           16字节      分区类型GUID

16          16字节      分区GUID

32          8字节       起始LBA（小端序）

40          8字节       末尾LBA

48          8字节       属性标签（如：bit60表示“只读”）

56          72字节      分区名（可以包括36个UTF-16（小端序）字符）